// Universal variable for selecting the board
window.board = "";

// Universal variable for manipulating the game
window.game = "";

// Universal variable stores the color player is for online
window.color = "WHITE";

// Universal variable used to cancel timer set Timeout loop
window.x;

// Stores the ID of any multiplayer game the player is currently playing
var gameId = "";

// UPDATE! SYNCED UP TIMER
// Stores the value of distance for an asy
var distanceTime = 0;

// Global variable for tracking the total number of players online
var playerNum = 0;

// Global variable for tracking number of game rooms in lobby
var numberOfRooms = 0;

// Global variable for quickly accessing firebase
var database = "";

// Global variable is empty when no board is loaded, but stores an array with game loadout on game load;
var boardOnScreen = "";

// Boolean is true when chessboard is non-interactive.
var lock = true;

// Boolean is true when microphone is on.
var micOn = false;

// Boolean is true when both players are present in an online game;
var bothPlayers = false;

// Boolean is true when online game is declared finished
var finish = false;

// stores a variety of starting positions as FEN strings
var varient = [
  "start",
  "rnbqkbnr/pppppppp/8/8/PPPPPPPP/PPPPPPPP/PPPPPPPP/PPPPKPPP w kq - 0 1",
  "rnbqkbnr/rnbbbbnr/pppppppp/8/8/8/PPPPPPPP/QQQQKQQQ w kq - 0 1",
  "brnqknrb/pppppppp/8/PpPpPpPp/pPpPpPpP/8/PPPPPPPP/BRNQKNRB b - - 0 1",
  "nnnnknnn/pppppppp/2p2p2/1pppppp1/8/8/PPPPPPPP/RNBQKBNR w KQ - 0 1",
  "kqbb4/nppp4/8/8/8/8/4PPPN/4BBQK w - - 0 1",
  "bbnnnnbb/pppqkppp/1pppppp1/8/3PP3/2PPPP2/PPPRKPPP/RRRRRRRR w - - 0 1",
  "rnbqkbnr/8/8/8/8/8/8/RNBQKBNR b KQkq - 0 1",
  "5ppp/5pkp/5ppp/8/8/8/8/5NKN w - - 0 1",
  "p2r1n1p/P1bppb1P/3k4/8/8/4K3/p1BPPB1p/P1N1R2P w - - 0 1",
  "rrrknrrr/pppppppp/8/8/8/8/PPPPPPPP/RRRNKRRR w - - 0 1"
];

// stores what varient is currently at play
var varientChoice = "";

// Beginning aux functions
function mainInit() {
  mainSays("User is now in the lobby.");
}
function screenResized() {
  mainSays("You resized your screen. Adjusting chessboard to compensate.");
  if (boardOnScreen != "") {
    // Since board is not responsive, reloading the game with exact settings and positioning
    // is vital.
    loadGame(
      boardOnScreen[0],
      boardOnScreen[1],
      boardOnScreen[2],
      boardOnScreen[3],
      window.game.fen()
    );
  }
}
// log to the console.
function mainSays(something, color, style) {
  if (typeof color === "undefined") {
    color = "orange";
  }
  if (typeof style === "undefined") {
    style = "italic";
  }
  console.log(
    "%c" + something,
    "font-style: " + style + "; color: " + color + ";"
  );
}

// When document has loaded, prepare firebase
$(document).ready(function () {
  fetch("/getConfig")
    .then((response) => response.json())
    .then((data) => {
      // Glitch doesn't recognize firebase, so undefined errors.
      firebase.initializeApp(data);
      database = firebase.database();
      // Call loadStuff, which loads a bunch of important stuff.
      loadStuff();
    })
    .catch((err) => {
      console.error("Error getting configuration from server:", err.message);
      database = "Database Error";
    });

  // Automatically unmute all sound
  //document.getElementById("volumeBut").innerHTML = "volume_up";
});

// Retrieve data from firebase and use it to load the lobby with the most recent data.
// Lots of firebase asynchronous monitoring will also be initialized here, to update the game when changes occur.
function loadStuff() {
  // prevents jQuery from triggering warnings when scroll and drag commands conflict each other
  jQuery.event.special.touchstart = {
    setup: function (_, ns, handle) {
      this.addEventListener("touchstart", handle, {
        passive: !ns.includes("noPreventDefault"),
      });
    },
  };
  database.ref("playerNumber").once("value", function (data) {
    // Increment firebase's player count by one
    database.ref("playerNumber").set(data.val() + 1);
  });

  // BEGIN MONITORING PLAYER NUMBER
  database.ref("playerNumber").on("value", function (data) {
    // When more players load the game, update playerNum to match.
    playerNum = data.val();
    if (playerNum < 0) {
      database.ref("playerNumber").set(0);
    }
    // Update player online counter in the lobby to show number of players
    $("#ponline").html("Players Online: " + playerNum);
  });

  // BEGIN MONITORING FOR NEW LOBBY GAME ROOMS
  database.ref("lobby/count").on("value", function (count) {
    if (count.val() < 0) {
      database.ref("lobby/count").set(0);
    }
    // Clear old rooms
    document.getElementById("roomList").textContent = "";
    // update numberOfRooms to match most recent
    numberOfRooms = count.val();
    updateLobby();
  });

  function updateLobby() {
    // Make new rooms
    if (numberOfRooms == 0) {
      // If there are no games, tell the user
      var node = document.createElement("P");
      node.innerHTML = "<b>No available games</b>"; // Set innerHTML
      node.style.paddingLeft = "10px";
      node.style.paddingRight = "10px";
      document.getElementById("roomList").appendChild(node); // Append <span> to <ul>
    } else {
      database.ref("lobby").once("value", function (data) {
        var data = data.val();
        var i;
        for (i = 0; i < numberOfRooms; i++) {
          let x = i;
          const game = data[Object.keys(data)[i]];

          // Create div element
          var node = document.createElement("DIV");

          // Create a passcode lock icon, depending on whether the game has a passcode or not
          var icon = document.createElement("SPAN");
          icon.classList.add("material-icons");
          // If the game has no password, set icon to open lock
          if (game.password == "") {
            icon.innerHTML = "lock_open";
          } else {
            // If it does have a password, lock icon
            icon.innerHTML = "lock";
          }
          node.appendChild(icon); // Append the icon to <div>

          // Create a span element containing the name of the game.
          var text = document.createElement("SPAN");
          text.innerHTML = game.name;
          text.setAttribute("class", "nameOfTheGame");
          node.appendChild(text); // Append the text to <div>

          // Listen for click event so that players can join
          $(text).on("click", function () {
            joinRoom(Object.keys(data)[x]);
          });

          // Create a span element to tell user if room if full or not.
          var capacity = document.createElement("SPAN");
          if (game.bothPlayers == false) {
            capacity.innerHTML = "1/2";
          } else {
            capacity.innerHTML = "2/2";
          }
          capacity.setAttribute("class", "capacityOfTheGame");
          node.appendChild(capacity); // Append the capacity to <div>

          // Create a span element containing the time of the game.
          if (game.seconds.toString().length < 2) {
            game.seconds = "0" + game.seconds;
          }
          var time = document.createElement("SPAN");
          time.innerHTML = game.minutes + ":" + game.seconds;
          time.setAttribute("class", "timeOfTheGame");
          node.appendChild(time); // Append the time to <div>

          // Finally, we have the finishd product
          document.getElementById("roomList").appendChild(node); // Append <div> to roomList
        }
      });
    }
  }
}

// create a new game room
function createRoom() {
  var gameName = document.getElementById("submitName").value.trim();
  const gamePass = document.getElementById("submitPass").value.trim();
  var min = document.getElementById("submitMin").value.trim();
  var sec = document.getElementById("submitSec").value.trim();
  const player = "white";

  // If no name is given, make game anonymous
  if (gameName == "") {
    gameName = "Unnamed Game";
  }

  if (sec == "") {
    sec = 0;
  }

  if (min == "") {
    min = 0;
  }

  // Converts smaller units to larger ones and store the leftovers (found using modulus) in new variables.
  // For example, if 120 seconds were selected, it would be converted into an additional 2 minutes.
  var seconds = sec % 60;
  var minutes = parseInt(min) + Math.floor(sec / 60);

  // If less than 2 minutes were set, stop execution and scold the user.
  if (minutes < 2) {
    document.getElementById("scold").style.display = "block";
    return;
  }

  // select a random gametype and set the varient
  var random = Math.floor(Math.random() * varient.length);
  varientChoice = varient[random];

  // Generate data to parse togther a new game
  var postData = {
    name: gameName,
    minutes: minutes,
    seconds: seconds,
    turn: player,
    move: "",
    bothPlayers: false,
    time: 0,
    password: gamePass,
    varNum: random,
  };

  // Get a key for a new Post.
  var newPostKey = database.ref().child("lobby").push().key;

  // Write the new post's data simultaneously in the posts list and the user's post list.
  var updates = {};
  updates["/lobby/" + newPostKey] = postData;
  database.ref().update(updates);

  // Update lobby count
  database.ref("lobby/count").set(numberOfRooms + 1);

  // Take the player to their room and await an opponent
  fade("#lobby", "#board");
  fade("#lobby", "#status");
  fade("#lobby", "#controls");
  loadGame(newPostKey, player, minutes, seconds, varientChoice);

  console.log("CREATED NEW ROOM: " + newPostKey);
}

// Join a room
function joinRoom(roomId) {
  let password = document.getElementById("validatePass").value;
  database.ref("lobby/" + roomId).once("value", function (data) {
    var room = data.val();
    // First, see if the room is full
    if (room.bothPlayers == true) {
      // If there is already a second player, then show pop up message
      $("#lobbylightbox").show();
      $("#roomSettings").hide();
      $("#popup").show();
      $("#popupText").html("This game is full");
      $("#popupPass").hide();
      return;
    } else if (room.password != password) {
      // If there is a password, ask for password
      $("#lobbylightbox").show();
      $("#roomSettings").hide();
      $("#popup").show();
      $("#popupText").html("Password required");
      $("#popupPass").show();
      $("#validate").on("click", function () {
        joinRoom(roomId);
      });
      return;
    } else {
      varientChoice = varient[room.varNum];
      $("#roomSettings").show();
      $("#popup").hide();
      $("#lobbylightbox").hide();
      password = "";
      console.log("JOINED NEW ROOM: " + roomId);

      // decide the starting position
      loadGame(roomId, "black", room.minutes, room.seconds, varientChoice);
      // prepare game sound effects
      setSound(0, "move.mp3");
      loadSound(0);
      setSound(1, "error.mp3");
      loadSound(1);
    }
  });
}

// BIG CHUNK OF IMPORTANT CODE.
// Load a Multiplayer game
function loadGame(roomId, player, minutes, seconds, position) {
  boardOnScreen = [roomId, player, minutes, seconds];

  // only runs on the first turn of the game
  if (position == varientChoice) {
    // Unlock the game
    lock = false;
    // hide lobby lighthouse
    $("#lobbylightbox").hide();
    // hide scold.
    $("#scold").hide();

    // Fade in all board elements
    fade("#selection", "#board");
    fade("#lobby", "#controls");
    fade("#lobby", "#status");

    // Reload any old games
    window.board = null;
    window.game = null;
    // Glitch does not recognize chess.js
    if (position == "start") {
      window.game = new Chess();
    } else {
      window.game = new Chess(varientChoice);
    }
  }

  // Chessboard configuration remains constant for all games
  var config = {
    draggable: true,
    position: position,
    onDragStart: onDragStart,
    onDrop: onDrop,
    onMouseoutSquare: onMouseoutSquare,
    onMouseoverSquare: onMouseoverSquare,
    onSnapEnd: onSnapEnd,
  };

  // Glitch does not recognize chessboard.js
  window.board = Chessboard("board", config);

  // Save player color
  window.color = "WHITE";
  // Flip the board if player plays black
  if (player == "black") {
    window.board.flip();
    window.color = "BLACK";
  }

  // set dragging rules and positioning. White is not allowed to touch black's pieces, and so forth.
  function onDragStart(source, piece, position, orientation) {
    // do not pick up pieces if the game is over
    if (window.game.game_over()) return false;

    // only pick up pieces if not locked
    // only pick up pieces if its your turn
    // only pick up your own pices
    if (lock == true) {
      return false;
    } else if (
      (window.game.turn() === "w" && piece.search(/^b/) !== -1) ||
      (window.game.turn() === "b" && piece.search(/^w/) !== -1)
    ) {
      return false;
    } else if (
      (player == "black" && piece.search(/^w/) !== -1) ||
      (player == "white" && piece.search(/^b/) !== -1)
    ) {
      return false;
    }
  }

  // When piece gets dropped
  function onDrop(source, target) {
    removeGreySquares();
    // see if the move is legal
    var move = window.game.move({
      from: source,
      to: target,
      promotion: "q", // NOTE: always promote to a queen for simplicity
    });

    // illegal move
    if (move === null) {
      window.soundFX[1].play();
      return "snapback";
    }

    window.soundFX[0].play();
    // update turn and move
    var turn = "white";
    if (window.game.turn() === "b") {
      turn = "black";
    }
    database.ref("lobby/" + roomId + "/move").set(source + target);
    database.ref("lobby/" + roomId + "/turn").set(turn);
    database.ref("lobby/" + roomId + "/time").set(distanceTime);
    updateStatus();
  }

  // Highlight all possible moves on hover
  function onMouseoverSquare(square, piece) {
    // get list of possible moves for this square
    var moves = window.game.moves({
      square: square,
      verbose: true,
    });

    // exit if there are no moves available for this square,
    // or if black chooses a white piece
    // or if white chooses a black piece
    // or if locked
    if (
      lock == true ||
      moves.length === 0 ||
      (player == "black" && piece.search(/^w/) !== -1) ||
      (player == "white" && piece.search(/^b/) !== -1)
    )
      return;

    // highlight the square they moused over
    greySquare(square);

    // highlight the possible squares for this piece
    for (var i = 0; i < moves.length; i++) {
      greySquare(moves[i].to);
    }
  }

  function onMouseoutSquare(square, piece) {
    // Only remove Grey Squares if game is unlocked
    if (lock == true) return;
    removeGreySquares();
  }

  // update the board position after the piece snap
  // for castling, en passant, pawn promotion
  function onSnapEnd() {
    window.board.position(window.game.fen());
  }

  // Now that the board is loaded, configure status bar and database
  if (position == varientChoice) {
    console.log("Loading Multiplayer Game");
    configure();
  }

  // Save roomid into global var gameId
  gameId = roomId;

  // If player is black, that means two players have entered the room.
  if (player == "black" && position == varientChoice) {
    database.ref("lobby/" + roomId + "/bothPlayers").set(true);
    bothPlayers = true;
    updateStatus();
    // Begin counting down with timer;
    startCountdown(minutes, seconds, roomId);
  } else if (player == "white" && gameId != "" && position == varientChoice) {
    // Show message and wait for other player to enter the game.
    // The lightbox message prevents white from touching their pieces
    database
      .ref("lobby/" + roomId + "/bothPlayers")
      .on("value", function (data) {
        if (data.val() == true) {
          // Hide the message, both players are here!
          bothPlayers = true;
          updateStatus();
          // Begin counting down with timer;
          startCountdown(minutes, seconds, roomId);
          message("hide", "hide");
        } else if (data.val() == false) {
          // Show the following message:
          message("Waiting for an opponent", "cancel");
        }
      });
  }

  // When other player makes a move, make the move on your chessboard
  database.ref("lobby/" + roomId + "/move").on("value", function (move) {
    const opponentMove = move.val();
    // When a move is "white" or "black", that means that player gas left the game,
    // which means that the game must end for the remaining player, who
    // terminates the game immediately upon recieving this information
    if (opponentMove == "NULL") {
      alert("Something apears to be... VERY WRONG");
    }

    if (opponentMove == "WHITE" && window.color == "BLACK") {
      bothPlayers = false;
      if (finish != true) {
        message("White has left the game", "exit");
      }
    }

    if (opponentMove == "BLACK" && window.color == "WHITE") {
      bothPlayers = false;
      if (finish != true) {
        message("Black has left the game", "exit");
      }
    }

    if (opponentMove != "WHITE" && opponentMove != "BLACK") {
      database.ref("lobby/" + roomId + "/turn").once("value", function (turn) {
        const playerTurn = turn.val();
        if (opponentMove != "" && player == playerTurn) {
          let array = opponentMove.split("");
          const source = array[0] + array[1];
          const target = array[2] + array[3];
          // Finally, make the move
          window.game.move({
            from: source,
            to: target,
            promotion: "q",
          });
          window.board.position(window.game.fen());
          updateStatus();
        }
      });
    }
  });
}

// Sets up status bar to suit different game modes
function configure() {
  // Configure status buttons for multiplayer play
  // cannot flip board
  $("#flip").hide();
  // cannot reset game
  $("#resetB").hide();
  // change exit to forfeit
  $("#exitB").html("Forfeit");
  $("#exitB").css("width", "9.5ch");
  document.getElementById("exitB").onclick = function () {
    exitBoard();
    return;
  };
}

// Updates current game status
function updateStatus() {
  if (window.game.turn() === "w") {
    $("#whiteTT").css("border-color", "dodgerblue");
    $("#blackTT").css("border-color", "#222");
    var currentTurn = "White";
  } else {
    $("#blackTT").css("border-color", "dodgerblue");
    $("#whiteTT").css("border-color", "#eee");
    var currentTurn = "Black";
  }

  // checkmate?
  if (window.game.in_checkmate()) {
    document.getElementById("TT").innerHTML = "Checkmate";
    // Declare player who's turn it is right now as the loser
    declare(currentTurn);
  }

  // draw? (king is cornered and can't move, but is not checkmated)
  // (50 moves with no decisive victory)
  // (too few peices for proper checkmate)
  else if (window.game.in_draw()) {
    document.getElementById("TT").innerHTML = "Draw";
    // Declare draw
    declare("Draw");
  }

  // stalemate? (occurs when the same position is repeated 3 times)
  else if (window.game.in_threefold_repetition()) {
    document.getElementById("TT").innerHTML = "Stalemate";
    // Declare draw
    declare("Stalemate");
  }

  // game is still going on
  else {
    document.getElementById("TT").innerHTML = currentTurn + "'s Turn";
    // check?
    if (window.game.in_check()) {
      document.getElementById("TT").innerHTML = currentTurn + " is in Check";
    }
  }
}

// Decalres winners and losers
function declare(loser) {
  finish = true;
  // Show lightbox
  $(".lightbox").show();
  $("#message1").show();
  $("#message2").hide();
  if (loser === "Black") {
    $("#message1").html("White Wins");
  } else if (loser === "White") {
    $("#message1").html("Black Wins");
  } else {
    $("#message1").html(loser);
  }

  // Insert text and style the exit button
  $("#button4").html("Exit");
  // Make it change color on hover with jQuery
  $("#button4").hover(function () {
    $(this).css("background-color", "#6390b5");
  });
  $("#button4").mouseout(function () {
    $(this).css("background-color", "#a5b4cb");
  });

  // When clicked, the button either takes you to lobby
  document.getElementById("button4").onclick = function () {
    finish = false;
    $(".lightbox").hide();
    exitBoard();
    return;
  };
}

// The first perameter sets what the message says, the second one decides what the button says.
// If both parameters are "hide", then hide the lightbox;
function message(content, button) {
  // Show lightbox
  if (content == "hide" && button == "hide") {
    $(".lightbox").hide();
  } else {
    $(".lightbox").show();
    $("#message1").hide();
    $("#message2").show();
  }

  // Set html of message2
  $("#message2").html(content);

  // Set buttons
  if (button == "cancel") {
    // set button text and css
    $("#button4").html("Cancel Game");
    $("#button4").hover(function () {
      $(this).css("background-color", "indianred");
    });
    $("#button4").mouseout(function () {
      $(this).css("background-color", "#a5b4cb");
    });
  } else if (button == "exit") {
    // set button text and css
    $("#button4").html("Exit");
    $("#button4").hover(function () {
      $(this).css("background-color", "#6390b5");
    });
    $("#button4").mouseout(function () {
      $(this).css("background-color", "#a5b4cb");
    });
  }

  // set button onclick
  document.getElementById("button4").onclick = function () {
    $(".lightbox").hide();
    exitBoard();
    return;
  };
}

function startCountdown(minValue, secValue, roomId) {
  distanceTime = 0;
  console.log("starting countdown");
  // convert to numbers
  if (secValue == "") {
    secValue = "00";
  }
  // easy getElementing
  var white = document.getElementById("whiteTT");
  var black = document.getElementById("blackTT");
  white.innerHTML = minValue + ":" + secValue;
  black.innerHTML = minValue + ":" + secValue;

  if (secValue == "00") {
    secValue = 0;
  }
  secValue = Number(secValue);
  minValue = Number(minValue);

  // convert all time values into miliseconds
  const basetime = minValue * 60 * 1000 + secValue * 1000;

  // Then, add them to current time
  const currentTime = new Date().getTime();
  var countdownWhite = currentTime + basetime;
  var countdownBlack = currentTime + basetime;

  // Compensate balences the time
  var compensate = 0;

  // Detect checks if a move was made using game fen
  var detect = window.game.fen();

  // Swap helps shift time
  var swap = false;

  // Set distance. Distance = time it takes to count to zero.
  // Distance will be continuously updated to track time
  var distance = 0;

  // Update the time set every 1/3 of a second;
  if (boardOnScreen != "") {
    window.x = setInterval(start, 333);
  }

  function start() {
    if (window.game.fen() != detect) {
      // Move detected!
      detect = window.game.fen();
      swap = true;
    }

    if (window.game.turn() === "w") {
      var turn = countdownWhite;
    } else if (window.game.turn() === "b") {
      var turn = countdownBlack;
    }

    let newTime = new Date().getTime();
    if (swap == true) {
      swap = false;
      database.ref("lobby/" + roomId + "/time").once("value", function (data) {
        distance = data.val();
        compensate = basetime - distance;
      });
    }
    distance = turn + compensate - newTime;
    distanceTime = distance;

    // I'm using date.getTime, as opposed to simply subtracting each second, for accuracy.
    // This stack overflow question convinced me: https://stackoverflow.com/questions/29971898/how-to-create-an-accurate-timer-in-javascript
    // The gist is that even if the browser stalls, the timing will still remain accurate.
    if (boardOnScreen != "") {
      // Time conversions for minutes and seconds
      var minutes = Math.floor(distance / (1000 * 60));
      var seconds = Math.floor((distance % (1000 * 60)) / 1000);

      // Adds zero to second if single digit
      if (seconds.toString().length < 2) {
        seconds = "0" + seconds;
      }

      let final = minutes + ":" + seconds;

      // Output the result in timer
      if (window.game.turn() === "w") {
        white.innerHTML = final;
      } else if (window.game.turn() === "b") {
        black.innerHTML = final;
      }

      // Activates when the countdown is over
      if (distance < 0) {
        // Stop the timer
        clearInterval(window.x);
        white.innerHTML = "00:00";
        black.innerHTML = "00:00";
        // Declare the loser
        if (window.game.turn() === "w") {
          declare("White");
        } else if (window.game.turn() === "b") {
          declare("Black");
        }
      }
    }
  }
}

// Highlights all possible moves with a greyish-blue tint
function greySquare(square) {
  // These are the highlight colors for legal moves
  const whiteSquareGrey = "#a5b4cb";
  const blackSquareGrey = "#6390b5";

  var $square = $("#board .square-" + square);

  let background = whiteSquareGrey;
  if ($square.hasClass("black-3c85d")) {
    background = blackSquareGrey;
  }

  $square.css("background", background);
}

// Romoves all highlights
function removeGreySquares() {
  $("#board .square-55d63").css("background", "");
}

// Exiting a board requires updating boardOnSceen and Lock variables
function exitBoard() {
  lock = true;
  // Reload any old games
  window.board = null;
  window.game = null;
  boardOnScreen = "";
  document.getElementById("lightb").style.display = "none";
  $(".lightbox").hide();

  fade("#board", "#lobby");
  fade("#controls", "#lobby");
  fade("#status", "#lobby");

  // Terminate game by calling the titular function
  clearInterval(window.x);
  if (bothPlayers == false) {
    terminate();
  } else {
    // Set new move in firebase as their color, so that other player will be alerted to
    // their opponent's absence
    database.ref("lobby/" + gameId + "/move").set(window.color);
    gameId = "";
    bothPlayers = false;
  }
}

// trims input to only allow two characters at a time
function crop(target) {
  if (target.className == "setText") {
    target.value = target.value.slice(0, 15);
  } else {
    target.value = target.value.slice(0, 2);
  }
}

// Removes a multiplayer game from lobby entirely
function terminate() {
  // DELETE THE ROOM IN FIREBASE COMPLETELY
  database.ref("lobby/" + gameId).remove();

  // Decrease number of games in the lobby by 1
  database.ref("lobby/count").set(numberOfRooms - 1);

  // Clear gameId
  gameId = "";

  // Make bothPlayers false;
  bothPlayers = false;
}

window.addEventListener("beforeunload", function (e) {
  // When player leaves game, decrease playerNum by 1
  database.ref("playerNumber").set(playerNum - 1);

  // If player was part of an online game and quit before finishing, terminate their game
  if (gameId != "") {
    clearInterval(window.x);
    // Set new move in firebase as terminate, so that other player will be alerted to
    // their opponent's absence
    if (bothPlayers == false) {
      terminate();
    } else {
      database.ref("lobby/" + gameId + "/move").set(window.color);
      gameId = "";
      bothPlayers = false;
    }
  }
});
